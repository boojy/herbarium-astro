'use strict';

var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var mdastUtilWikiLink = require('mdast-util-wiki-link');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);

function wikiLinkTransclusionFormat(extension) {
  var transclusionFormats = [/\.jpe?g$/, /\.a?png$/, /\.webp$/, /\.avif$/, /\.gif$/, /\.svg$/, /\.bmp$/, /\.ico$/, /\.pdf$/];
  var supportedFormat = extension.match(transclusionFormats.filter(function (r) {
    return extension.match(r);
  })[0])[0];
  var strippedExtension = extension.match(/\.[0-9a-z]{1,4}$/gi);
  if (!supportedFormat) return [false, strippedExtension && strippedExtension[0].replace('.', '')];
  return [true, supportedFormat.replace('.', '')];
}

function fromMarkdown() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var permalinks = opts.permalinks || [];

  var defaultPageResolver = function defaultPageResolver(name) {
    return [name.replace(/ /g, '-')];
  };

  var pageResolver = opts.pageResolver || defaultPageResolver;
  var newClassName = opts.newClassName || 'new';
  var wikiLinkClassName = opts.wikiLinkClassName || 'internal';

  var defaultHrefTemplate = function defaultHrefTemplate(permalink) {
    if (permalink.startsWith('#')) return permalink;
    return "/".concat(permalink);
  };

  var hrefTemplate = opts.hrefTemplate || defaultHrefTemplate;

  function enterWikiLink(token) {
    this.enter({
      type: 'wikiLink',
      isType: token.isType ? token.isType : null,
      value: null,
      data: {
        alias: null,
        permalink: null,
        exists: null
      }
    }, token);
  }

  function top(stack) {
    return stack[stack.length - 1];
  }

  function exitWikiLinkAlias(token) {
    var alias = this.sliceSerialize(token);
    var current = top(this.stack);
    current.data.alias = alias;
  }

  function exitWikiLinkTarget(token) {
    var target = this.sliceSerialize(token);
    var current = top(this.stack);
    current.value = target;
  }

  function exitWikiLink(token) {
    var wikiLink = this.exit(token); // if (opts.markdownFolder && wikiLink.value.includes(`${opts.markdownFolder}/`)) {
    //   const [, ...value] = wikiLink.value.split(`${opts.markdownFolder}/`)
    //   wikiLink.value = value
    // }

    var wikiLinkTransclusion = wikiLink.isType === 'transclusions';
    var pagePermalinks = pageResolver(wikiLink.value);
    var permalink = pagePermalinks.find(function (p) {
      var heading = '';

      if (!wikiLinkTransclusion && p.match(/#/)) {
        var _p$split = p.split('#');

        var _p$split2 = _slicedToArray__default['default'](_p$split, 2);

        heading = _p$split2[1];
      }

      var link = heading ? p.replace("#".concat(heading), '') : p;
      return permalinks.indexOf(link) !== -1;
    });
    var exists = permalink !== undefined;

    if (!exists) {
      permalink = pagePermalinks[0];
    }

    var regex = /\/?index(?![\w\S])|\/?index(?=#)/g;

    if (!wikiLinkTransclusion && permalink.match(regex)) {
      permalink = permalink.replace(regex, '');
    }

    var displayName;
    var transclusionFormat;

    if (wikiLinkTransclusion) {
      transclusionFormat = wikiLinkTransclusionFormat(wikiLink.value);

      if (!transclusionFormat[0]) {
        displayName = "Document type ".concat(transclusionFormat[1] ? transclusionFormat[1].toUpperCase() : null, " is not yet supported for transclusion");
        console.warn(displayName);
        wikiLink.data.hName = 'span';
        wikiLink.data.hChildren = [{
          type: 'text',
          value: displayName
        }];
      } else {
        var _regex = new RegExp("".concat(transclusionFormat[1], "$"), 'g');

        displayName = wikiLink.value.replace(_regex, '');

        if (transclusionFormat[1] === 'pdf') {
          wikiLink.data.hName = 'embed';
        } else {
          wikiLink.data.hName = 'img';
        }
      }
    } else {
      if (wikiLink.value.startsWith('#')) {
        displayName = wikiLink.value.replace('#', '');
      } else {
        displayName = wikiLink.value;
      }

      wikiLink.data.hName = 'a';
    }

    if (wikiLink.data.alias && !wikiLinkTransclusion) {
      displayName = wikiLink.data.alias;
    }

    var classNames = wikiLinkClassName;

    if (!exists) {
      classNames += ' ' + newClassName;
    }

    wikiLink.data.alias = displayName;

    if (wikiLinkTransclusion && transclusionFormat[1] === 'pdf') {
      wikiLink.data.permalink = permalink + '#view=Fit';
    } else {
      wikiLink.data.permalink = permalink;
    }

    wikiLink.data.exists = exists;

    if (wikiLinkTransclusion) {
      if (!transclusionFormat[0]) {
        wikiLink.data.hProperties = {
          className: classNames + ' no-support',
          style: 'color:#fef08a;',
          src: hrefTemplate(permalink)
        };
      } else if (transclusionFormat[1] === 'pdf') {
        wikiLink.data.hProperties = {
          className: classNames,
          width: '100%',
          style: 'height:100vh;',
          type: 'application/pdf',
          src: hrefTemplate(permalink) + '#view=Fit'
        };
      } else {
        wikiLink.data.hProperties = {
          className: classNames,
          src: hrefTemplate(permalink)
        };
      }
    } else {
      wikiLink.data.hProperties = {
        className: classNames,
        href: hrefTemplate(permalink)
      };
      wikiLink.data.hChildren = [{
        type: 'text',
        value: displayName
      }];
    }
  }

  return {
    enter: {
      wikiLink: enterWikiLink
    },
    exit: {
      wikiLinkTarget: exitWikiLinkTarget,
      wikiLinkAlias: exitWikiLinkAlias,
      wikiLink: exitWikiLink
    }
  };
}

var codes = {
  horizontalTab: -2,
  virtualSpace: -1,
  nul: 0,
  eof: null,
  space: 32
};

function markdownLineEndingOrSpace(code) {
  return code < codes.nul || code === codes.space;
}

function markdownLineEnding(code) {
  return code < codes.horizontalTab;
}

function wikiLink() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var aliasDivider = opts.aliasDivider || ':';
  var aliasMarker = aliasDivider;
  var startMarker = '[[';
  var imageStartMarker = '![[';
  var endMarker = ']]';

  function tokenize(effects, ok, nok) {
    var data;
    var alias;
    var aliasCursor = 0;
    var startMarkerCursor = 0;
    var endMarkerCursor = 0;
    return start;

    function start(code) {
      if (code === startMarker.charCodeAt(startMarkerCursor)) {
        effects.enter('wikiLink');
        effects.enter('wikiLinkMarker');
        return consumeStart(code);
      } else if (code === imageStartMarker.charCodeAt(startMarkerCursor)) {
        effects.enter('wikiLink', {
          isType: 'transclusions'
        });
        effects.enter('wikiLinkMarker', {
          isType: 'transclusions'
        });
        return consumeStart(code);
      } else {
        return nok(code);
      }
    }

    function consumeStart(code) {
      if (startMarkerCursor === startMarker.length) {
        effects.exit('wikiLinkMarker');
        return consumeData(code);
      }

      if (code === startMarker.charCodeAt(startMarkerCursor) || code === imageStartMarker.charCodeAt(startMarkerCursor)) {
        effects.consume(code);
        if (code === 91) startMarkerCursor++;
        return consumeStart;
      } else {
        return nok(code);
      }
    }

    function consumeData(code) {
      if (markdownLineEnding(code) || code === codes.eof) {
        return nok(code);
      }

      effects.enter('wikiLinkData');
      effects.enter('wikiLinkTarget');
      return consumeTarget(code);
    }

    function consumeTarget(code) {
      if (code === aliasMarker.charCodeAt(aliasCursor)) {
        if (!data) return nok(code);
        effects.exit('wikiLinkTarget');
        effects.enter('wikiLinkAliasMarker');
        return consumeAliasMarker(code);
      }

      if (code === endMarker.charCodeAt(endMarkerCursor)) {
        if (!data) return nok(code);
        effects.exit('wikiLinkTarget');
        effects.exit('wikiLinkData');
        effects.enter('wikiLinkMarker');
        return consumeEnd(code);
      }

      if (markdownLineEnding(code) || code === codes.eof) {
        return nok(code);
      }

      if (!markdownLineEndingOrSpace(code)) {
        data = true;
      }

      effects.consume(code);
      return consumeTarget;
    }

    function consumeAliasMarker(code) {
      if (aliasCursor === aliasMarker.length) {
        effects.exit('wikiLinkAliasMarker');
        effects.enter('wikiLinkAlias');
        return consumeAlias(code);
      }

      if (code !== aliasMarker.charCodeAt(aliasCursor)) {
        return nok(code);
      }

      effects.consume(code);
      aliasCursor++;
      return consumeAliasMarker;
    }

    function consumeAlias(code) {
      if (code === endMarker.charCodeAt(endMarkerCursor)) {
        if (!alias) return nok(code);
        effects.exit('wikiLinkAlias');
        effects.exit('wikiLinkData');
        effects.enter('wikiLinkMarker');
        return consumeEnd(code);
      }

      if (markdownLineEnding(code) || code === codes.eof) {
        return nok(code);
      }

      if (!markdownLineEndingOrSpace(code)) {
        alias = true;
      }

      effects.consume(code);
      return consumeAlias;
    }

    function consumeEnd(code) {
      if (endMarkerCursor === endMarker.length) {
        effects.exit('wikiLinkMarker');
        effects.exit('wikiLink');
        return ok(code);
      }

      if (code !== endMarker.charCodeAt(endMarkerCursor)) {
        return nok(code);
      }

      effects.consume(code);
      endMarkerCursor++;
      return consumeEnd;
    }
  }

  var call = {
    tokenize: tokenize
  };
  return {
    text: {
      91: call,
      33: call // 91: left square bracket, 33: exclamation mark

    }
  };
}

var fs = require('fs');

var path = require('path');

var pipe = function pipe() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function (x) {
    return fns.reduce(function (v, f) {
      return f(v);
    }, x);
  };
};

var flattenArray = function flattenArray(input) {
  return input.reduce(function (acc, item) {
    return [].concat(_toConsumableArray__default['default'](acc), _toConsumableArray__default['default'](Array.isArray(item) ? item : [item]));
  }, []);
};

var map = function map(fn) {
  return function (input) {
    return input.map(fn);
  };
};

var walkDir = function walkDir(fullPath) {
  return fs.statSync(fullPath).isFile() ? fullPath : getAllFilesRecursively(fullPath);
};

var pathJoinPrefix = function pathJoinPrefix(prefix) {
  return function (extraPath) {
    return path.join(prefix, extraPath);
  };
};

var getAllFilesRecursively = function getAllFilesRecursively(folder) {
  return pipe(fs.readdirSync, map(pipe(pathJoinPrefix(folder), walkDir)), flattenArray)(folder);
};

function getFiles(type) {
  var prefixPaths = path.join(process.cwd(), type);
  var files = getAllFilesRecursively(prefixPaths); // Only want to return path and ignore root, replace is needed to work on Windows

  return files.map(function (file) {
    return file.slice(prefixPaths.length + 1).replace(/\\/g, '/');
  });
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var warningIssued;

function wikiLinkPlugin() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    markdownFolder: ''
  };
  var data = this.data();

  function add(field, value) {
    if (data[field]) data[field].push(value);else data[field] = [value];
  }

  if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
    warningIssued = true;
    console.warn('[remark-wiki-link] Warning: please upgrade to remark 13 to use this plugin');
  }

  opts = _objectSpread({}, opts, {
    aliasDivider: opts.aliasDivider ? opts.aliasDivider : '|',
    pageResolver: opts.pageResolver ? opts.pageResolver : function (name) {
      var image = wikiLinkTransclusionFormat(name)[1];
      var heading = '';

      if (!image && !name.startsWith('#') && name.match(/#/)) {
        var _name$split = name.split('#');

        var _name$split2 = _slicedToArray__default['default'](_name$split, 2);

        heading = _name$split2[1];
        name = name.replace("#".concat(heading), '');
      } else if (name.startsWith('#')) {
        name = name.toLowerCase();
      }

      if (opts.permalinks || opts.markdownFolder) {
        var url = opts.permalinks.find(function (p) {
          return p === name || p.split('/').pop() === name && !opts.permalinks.includes(p.split('/').pop());
        });

        if (url) {
          if (heading) return ["".concat(url, "#").concat(heading.toLowerCase()).replace(/ /g, '-')];
          return image ? [url] : [url.replace(/ /g, '-')];
        }
      }

      return image ? [name] : [name.replace(/ /g, '-')];
    },
    permalinks: opts.markdownFolder ? getFiles(opts.markdownFolder).map(function (file) {
      return file.replace(/\.mdx?$/, '');
    }) : opts.permalinks
  });
  add('micromarkExtensions', wikiLink(opts));
  add('fromMarkdownExtensions', fromMarkdown(opts));
  add('toMarkdownExtensions', mdastUtilWikiLink.toMarkdown(opts));
}

wikiLinkPlugin.wikiLinkPlugin = wikiLinkPlugin;

module.exports = wikiLinkPlugin;
